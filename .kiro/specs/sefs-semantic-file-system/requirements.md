# SEFS: Semantic Entropy File System - Requirements

## 1. Project Overview

### 1.1 Vision
Build a self-organizing file manager with OS-level integration that automatically clusters files based on semantic similarity, visualized through an interactive gravity well metaphor.

### 1.2 Core Innovation
- **Semantic Gravity Wells**: Files automatically cluster based on content similarity
- **OS-Level Synchronization**: Real folders created/updated automatically
- **Live Visualization**: Dynamic 2D interface showing semantic relationships
- **AI-Powered Naming**: Intelligent agents generate meaningful folder names

### 1.3 Technology Stack
- **Backend**: Python 3.11, FastAPI, Watchdog
- **ML/AI**: SentenceTransformers, scikit-learn, CrewAI
- **Frontend**: React, D3.js
- **Storage**: Local filesystem, JSON state

## 2. User Stories

### 2.1 File Monitoring
**As a user**, I want the system to automatically detect when I add PDF or text files to a monitored directory, so that I don't have to manually trigger organization.

**Acceptance Criteria**:
- System monitors a designated root directory (e.g., `sefs_root/`)
- Detects new `.pdf` and `.txt` files in real-time
- Triggers processing pipeline when files are added
- Handles file modifications and deletions
- Provides feedback on detected files

### 2.2 Content Extraction
**As a user**, I want the system to extract text content from my documents, so that semantic analysis can be performed.

**Acceptance Criteria**:
- Extracts text from PDF files using PyPDF2
- Reads text from .txt files with proper encoding
- Handles extraction errors gracefully
- Provides content previews (first 500 characters)
- Logs extraction statistics (character count, pages)

### 2.3 Semantic Clustering
**As a user**, I want files with similar content to be automatically grouped together, so that related documents are organized without manual effort.

**Acceptance Criteria**:
- Generates embeddings using SentenceTransformers (all-MiniLM-L6-v2 model)
- Clusters files using DBSCAN algorithm based on cosine similarity
- Creates meaningful clusters (minimum 2 files per cluster by default)
- Handles single files and edge cases
- Provides cluster statistics and distribution
- Reclusters when new files are added

### 2.4 OS-Level Folder Management
**As a user**, I want the system to create actual folders on my operating system and move files into them, so that the organization is real and persistent.

**Acceptance Criteria**:
- Creates folders in the monitored root directory
- Folder names are OS-compatible (sanitized special characters)
- Moves files to appropriate cluster folders
- Handles filename collisions (appends counter)
- Maintains bidirectional sync (OS ↔ System state)
- Cleans up empty folders automatically
- Preserves file integrity during moves

### 2.5 AI-Powered Folder Naming
**As a user**, I want folders to have meaningful, descriptive names generated by AI, so that I can understand what's in each folder at a glance.

**Acceptance Criteria**:
- Uses CrewAI agents to analyze cluster content
- Generates concise names (2-4 words)
- Names reflect actual content themes
- Avoids generic terms like "Files" or "Documents"
- Provides reasoning for name choices
- Handles API failures gracefully with fallback names

### 2.6 Real-Time Visualization
**As a user**, I want to see a beautiful, interactive visualization of how my files are being organized, so that I understand the semantic relationships.

**Acceptance Criteria**:
- Displays files as nodes in a 2D space
- Shows cluster centers as "gravity wells" with pulsing animations
- Files are pulled toward their cluster centers
- Color-coded by cluster
- Interactive drag-and-drop for exploration
- Smooth animations and transitions
- Shows file count badges on clusters
- Displays file names and cluster names
- Responsive to window size

### 2.7 Activity Feed
**As a user**, I want to see a live feed of system activities, so that I know what the system is doing.

**Acceptance Criteria**:
- Shows recent file additions
- Displays clustering events
- Shows folder creation/updates
- Timestamps for each activity
- Limited to last 10 activities
- Auto-scrolls with new activities

### 2.8 REST API
**As a developer/user**, I want a REST API to interact with the system programmatically, so that I can integrate SEFS with other tools.

**Acceptance Criteria**:
- GET `/health` - Health check endpoint
- GET `/files` - List all indexed files
- GET `/clusters` - Get cluster information
- GET `/folders` - Get OS folder structure
- GET `/graph` - Get visualization data
- GET `/state` - Get complete system state
- GET `/history` - Get clustering history
- POST `/reorganize` - Manually trigger reorganization
- POST `/generate-names` - Generate AI-powered names
- WebSocket `/ws` - Real-time updates

### 2.9 State Persistence
**As a user**, I want the system to remember its state across restarts, so that I don't lose organization history.

**Acceptance Criteria**:
- Saves state to `.sefs_state.json`
- Saves history to `.sefs_history.json`
- Persists file-to-cluster mappings
- Stores cluster names and metadata
- Keeps last 50 history snapshots
- Loads state on startup
- Handles corrupted state files gracefully

### 2.10 Demo Showcase
**As a hackathon participant**, I want to demonstrate the system with impressive sample data, so that judges understand the innovation.

**Acceptance Criteria**:
- Demo script creates 9 sample files (3 AI papers, 3 recipes, 3 travel guides)
- Files cluster into 3 distinct semantic groups
- Visualization shows clear separation
- AI generates meaningful names for each cluster
- Live demonstration of adding new files
- Shows OS folder integration clearly

## 3. Technical Requirements

### 3.1 Performance
- File processing: < 2 seconds per file
- Clustering: < 5 seconds for up to 50 files
- UI updates: < 500ms latency
- WebSocket updates: Real-time (< 100ms)

### 3.2 Scalability
- Support up to 100 files initially
- Graceful degradation with larger datasets
- Efficient embedding caching
- Incremental clustering updates

### 3.3 Reliability
- Atomic file operations (no data loss)
- Error recovery for failed moves
- Graceful handling of API failures
- Logging for debugging

### 3.4 Compatibility
- Windows, macOS, Linux support
- Python 3.11+
- Modern browsers (Chrome, Firefox, Safari)
- Node.js 18+

### 3.5 Security
- No external network access (except AI API)
- File operations restricted to root directory
- Input sanitization for folder names
- No execution of file contents

## 4. Non-Functional Requirements

### 4.1 Usability
- Zero configuration for basic usage
- Clear visual feedback
- Intuitive gravity well metaphor
- Helpful error messages

### 4.2 Maintainability
- Modular architecture
- Clear separation of concerns
- Comprehensive logging
- Code documentation

### 4.3 Testability
- Unit tests for each component
- Integration tests for workflows
- System tests for end-to-end scenarios
- Demo test script

## 5. Constraints

### 5.1 Time Constraint
- 6-hour hackathon implementation window
- Must prioritize core features
- Minimal viable product approach

### 5.2 Resource Constraints
- Local execution (no cloud services)
- Free/open-source libraries only
- OpenAI API for CrewAI (requires key)

### 5.3 Scope Constraints
- PDF and text files only (no DOCX, images, etc.)
- Single-level hierarchy (no sub-clusters)
- English content only
- Local filesystem only (no cloud storage)

## 6. Success Criteria

### 6.1 Functional Success
- ✅ Files automatically detected and processed
- ✅ Semantic clustering produces meaningful groups
- ✅ OS folders created and files moved correctly
- ✅ AI generates descriptive folder names
- ✅ Visualization displays gravity wells beautifully
- ✅ Real-time updates work smoothly

### 6.2 Demo Success
- ✅ 5-minute demo runs without errors
- ✅ Judges understand the innovation
- ✅ Visual impact is impressive
- ✅ OS integration is clearly demonstrated
- ✅ AI naming shows intelligence

### 6.3 Judging Criteria Alignment
- **Innovation (30%)**: OS-level integration, semantic gravity metaphor
- **Technical Implementation (30%)**: Multi-technology stack, clean architecture
- **User Experience (20%)**: Stunning visualization, intuitive interface
- **Completeness (20%)**: All features working, documented, demo-ready

## 7. Out of Scope (Future Enhancements)

### 7.1 Not in Initial Release
- Support for DOCX, PPTX, images
- Multi-level folder hierarchies
- Manual cluster editing
- Search functionality
- Cloud storage integration
- Mobile app
- Browser extension
- Collaborative features
- Multi-language support
- Custom clustering parameters UI

### 7.2 Future Considerations
- Timeline view of reorganization history
- Export/import functionality
- User preferences and settings
- Advanced analytics dashboard
- Integration with existing file managers

## 8. Dependencies

### 8.1 Python Packages
- fastapi==0.104.1
- uvicorn[standard]==0.24.0
- watchdog==3.0.0
- sentence-transformers==2.2.2
- scikit-learn==1.3.2
- PyPDF2==3.0.1
- python-multipart==0.0.6
- numpy==1.26.2
- pandas==2.1.3
- crewai==0.28.0
- crewai-tools==0.2.6

### 8.2 Node Packages
- react
- d3
- axios

### 8.3 External Services
- OpenAI API (for CrewAI agents)

## 9. Risks and Mitigations

### 9.1 Risk: Clustering Quality
**Mitigation**: Use proven DBSCAN algorithm, tune parameters, provide manual override

### 9.2 Risk: AI API Failures
**Mitigation**: Fallback to keyword-based naming, cache successful names

### 9.3 Risk: File Operation Errors
**Mitigation**: Atomic operations, error recovery, comprehensive logging

### 9.4 Risk: Performance with Large Files
**Mitigation**: Limit content extraction to first 5000 characters, optimize embeddings

### 9.5 Risk: Demo Failures
**Mitigation**: Pre-test thoroughly, have backup video, prepare contingency plan

## 10. Acceptance Testing Scenarios

### 10.1 Scenario: Basic Organization
1. Start with empty `sefs_root/` directory
2. Add 3 AI papers, 3 recipes, 3 travel guides
3. Verify 3 clusters are created
4. Verify 3 OS folders exist with correct files
5. Verify visualization shows 3 gravity wells

### 10.2 Scenario: AI Naming
1. System has clustered files
2. Trigger AI name generation
3. Verify meaningful names appear (not "Cluster_0")
4. Verify OS folders are renamed
5. Verify visualization updates

### 10.3 Scenario: Real-Time Updates
1. System is running with existing files
2. Add a new file to `sefs_root/`
3. Verify file appears in UI within 3 seconds
4. Verify reclustering occurs
5. Verify file moves to correct folder

### 10.4 Scenario: State Persistence
1. Organize files and generate names
2. Stop the system
3. Restart the system
4. Verify state is restored
5. Verify history is preserved

### 10.5 Scenario: Edge Cases
1. Add single file (should create cluster of 1)
2. Add duplicate filename (should handle collision)
3. Add empty file (should handle gracefully)
4. Delete file while system running (should update)
5. Add very large file (should limit content extraction)

## 11. Documentation Requirements

### 11.1 User Documentation
- Quick start guide
- Demo script
- Troubleshooting guide
- FAQ

### 11.2 Developer Documentation
- Architecture overview
- Component descriptions
- API documentation
- Setup instructions

### 11.3 Demo Materials
- Presentation slides
- Demo video (backup)
- Sample dataset
- Talking points

## 12. Glossary

- **Semantic Clustering**: Grouping files based on content meaning, not just keywords
- **Gravity Well**: Visual metaphor for cluster centers that "pull" related files
- **Embedding**: Vector representation of text content for similarity comparison
- **DBSCAN**: Density-Based Spatial Clustering algorithm
- **CrewAI**: Framework for building AI agent systems
- **SentenceTransformers**: Library for generating semantic embeddings
- **Bidirectional Sync**: Two-way synchronization between UI and OS filesystem
